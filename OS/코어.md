CPU 내부에서 독립적으로 명령어를 실행할 수 있는 물리적 처리 단위입니다.

## 핵심 개념

코어는 각각 자체적으로 **연산 장치(ALU)**, **제어 장치(CU)**, **레지스터**를 갖고 있어 독립적으로 명령어를 fetch → decode → execute 할 수 있습니다.

```
[ CPU ]
├── 코어 1: [ALU + CU + 레지스터] ← 독립적 명령어 처리
├── 코어 2: [ALU + CU + 레지스터] ← 독립적 명령어 처리
├── 코어 3: [ALU + CU + 레지스터] ← 독립적 명령어 처리
├── 코어 4: [ALU + CU + 레지스터] ← 독립적 명령어 처리
├── L3 캐시 (공유)
└── 메모리 컨트롤러 (공유)
```

## 코어 vs [[스레드]] vs [[프로세스]]

|항목|코어 (Core)|스레드 (Thread)|프로세스 (Process)|
|---|---|---|---|
|**정의**|CPU의 물리적 처리 단위|코어가 처리하는 작업 흐름|실행 중인 프로그램 단위|
|**수준**|하드웨어|하드웨어 / 소프트웨어|소프트웨어|
|**자원**|자체 ALU, CU, 레지스터 보유|코어의 자원을 공유 또는 분할|독립된 메모리 공간 보유|
|**병렬성**|진정한 병렬 처리|논리적 병렬 처리|OS가 코어에 스케줄링|

## 싱글코어 vs 멀티코어

|항목|싱글코어|멀티코어|
|---|---|---|
|**동시 처리**|시분할(Time-Sharing)로 동시 처리처럼 보임|실제로 여러 작업을 동시에 처리|
|**성능 확장**|클럭 속도 향상에 의존 (발열 한계)|코어 수 증가로 성능 확장|
|**전력 효율**|고클럭 → 높은 전력 소모|저클럭 × 다수 코어 → 효율적|

```
싱글코어 (시분할)
코어1: [작업A][작업B][작업A][작업B]...  → 번갈아 처리 (동시처럼 보임)

멀티코어 (진정한 병렬)
코어1: [작업A][작업A][작업A]...  ↘
                                  → 실제 동시 처리
코어2: [작업B][작업B][작업B]...  ↗
```

## 하이퍼스레딩 (Hyper-Threading)

하나의 물리 코어가 **2개의 논리적 스레드**를 동시에 처리하는 기술입니다.

```
물리 코어 4개 + 하이퍼스레딩
→ 논리 프로세서 8개 (OS에는 8개 코어처럼 보임)

[ 물리 코어 1 ]
├── 논리 스레드 1  ← 독립적 레지스터 세트
└── 논리 스레드 2  ← 독립적 레지스터 세트
      ↑ ALU, 캐시 등은 공유
```

|항목|물리 코어 추가|하이퍼스레딩|
|---|---|---|
|**성능 향상**|~100%|~15~30%|
|**비용**|높음 (트랜지스터 증가)|낮음 (약 5% 면적 증가)|
|**효과**|진정한 병렬 처리|코어 유휴 시간 활용|

## Java에서 코어 활용

```java
public class CoreExample {
    public static void main(String[] args) {
        // 사용 가능한 논리 프로세서(코어) 수 확인
        int cores = Runtime.getRuntime().availableProcessors();
        System.out.println("논리 프로세서 수: " + cores);  // 예: 8

        // 코어 수에 맞춘 스레드 풀 생성
        ExecutorService cpuBoundPool = Executors.newFixedThreadPool(cores);
        ExecutorService ioBoundPool  = Executors.newFixedThreadPool(cores * 2);

        // 병렬 스트림 (내부적으로 ForkJoinPool, 코어 수 - 1개 스레드 사용)
        long count = LongStream.rangeClosed(1, 10_000_000)
                .parallel()
                .filter(n -> isPrime(n))
                .count();
    }
}
```

## 스레드 풀 크기 가이드

|작업 유형|권장 스레드 수|이유|
|---|---|---|
|**CPU 바운드** (연산 위주)|코어 수|코어보다 많으면 컨텍스트 스위칭 오버헤드만 증가|
|**I/O 바운드** (네트워크, DB)|코어 수 × 2 이상|I/O 대기 중 유휴 코어를 다른 스레드가 활용|
|**혼합형**|코어 수 × (1 + 대기시간/처리시간)|작업 특성에 따라 조절|

> **실무 팁**: 단순히 코어 수를 늘린다고 성능이 비례하여 향상되지는 않습니다. **암달의 법칙(Amdahl's Law)**에 따르면, 프로그램의 순차 실행 부분이 병렬화의 상한선을 결정하므로, 병렬화 가능한 부분의 비율을 높이는 것이 핵심입니다.