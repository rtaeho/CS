렉시컬 스코프(Lexical Scope)는 **함수가 선언된 위치에 따라 상위 스코프가 결정되는 방식**입니다.

## 핵심 개념

```javascript
const x = 10;

function outer() {
    const x = 20;
    
    function inner() {
        console.log(x);  // 어떤 x를 참조할까?
    }
    
    return inner;
}

const fn = outer();
fn();  // 20 출력
```

`inner` 함수는 **선언된 위치**(outer 내부)를 기준으로 스코프를 결정합니다.

## 렉시컬 스코프 vs [[동적 스코프]]

|구분|스코프 결정 시점|기준|
|---|---|---|
|**렉시컬 스코프**|함수 선언 시|어디서 선언했는가|
|**동적 스코프**|함수 호출 시|어디서 호출했는가|

```javascript
const x = 10;

function foo() {
    console.log(x);
}

function bar() {
    const x = 20;
    foo();  // 렉시컬: 10 / 동적: 20
}

bar();  // JavaScript는 렉시컬 스코프 → 10 출력
```

## 스코프 체인

렉시컬 스코프는 **스코프 체인**을 형성합니다.

```javascript
const a = 1;  // 전역 스코프

function outer() {
    const b = 2;  // outer 스코프
    
    function inner() {
        const c = 3;  // inner 스코프
        console.log(a, b, c);  // 1, 2, 3
    }
    
    inner();
}

outer();
```

```
inner 스코프 (c)
    ↓ 없으면 상위로
outer 스코프 (b)
    ↓ 없으면 상위로
전역 스코프 (a)
```

## 클로저와의 관계

렉시컬 스코프 덕분에 **클로저**가 가능합니다.

```javascript
function createCounter() {
    let count = 0;  // 렉시컬 환경에 저장
    
    return function() {
        return ++count;  // 선언 당시의 count를 기억
    };
}

const counter = createCounter();
counter();  // 1
counter();  // 2
counter();  // 3
```

`createCounter` 실행이 끝나도, 반환된 함수는 **선언 시점의 렉시컬 환경**(count 변수)을 계속 참조합니다.

## 요약

| 항목     | 설명                      |
| ------ | ----------------------- |
| **정의** | 함수 선언 위치 기준으로 스코프 결정    |
| **특징** | 코드 작성 시점에 스코프가 확정됨 (정적) |
| **장점** | 코드만 보고 스코프 예측 가능        |
| **활용** | 클로저, 모듈 패턴 등            |
