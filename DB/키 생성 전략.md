데이터베이스에서 기본 키(Primary Key) 값을 자동으로 생성하는 방법입니다. JPA에서 `@GeneratedValue`로 지정합니다.

## 왜 필요한가?

- 매번 수동으로 키 값을 지정하기 번거로움
- 중복 없는 고유한 값 보장 필요
- DB나 상황에 따라 적합한 전략이 다름

## JPA 키 생성 전략

|전략|설명|
|---|---|
|**IDENTITY**|DB의 auto_increment 사용|
|**SEQUENCE**|DB 시퀀스 사용|
|**TABLE**|별도 키 생성 테이블 사용|
|**AUTO**|DB에 맞게 자동 선택|
|**UUID**|랜덤 고유 문자열|

## 각 전략 상세

### IDENTITY

```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
```

- MySQL, PostgreSQL의 auto_increment 사용
- INSERT 후에 ID를 알 수 있음
- 단점: 배치 INSERT 불가 (매번 INSERT해야 ID 확인)

### SEQUENCE

```java
@Id
@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "user_seq")
@SequenceGenerator(name = "user_seq", sequenceName = "user_sequence", allocationSize = 50)
private Long id;
```

- Oracle, PostgreSQL에서 주로 사용
- allocationSize로 미리 ID 확보 → 성능 향상
- INSERT 전에 ID를 알 수 있음

### TABLE

```java
@Id
@GeneratedValue(strategy = GenerationType.TABLE)
private Long id;
```

- 키 생성용 별도 테이블 사용
- 모든 DB에서 사용 가능
- 단점: 성능 낮음 (잘 안 씀)

### UUID

```java
@Id
@GeneratedValue(strategy = GenerationType.UUID)
private String id;  // "550e8400-e29b-41d4-a716-446655440000"
```

- 분산 환경에서 충돌 없이 생성
- 단점: 길고, 정렬 어려움, 인덱스 성능 저하

## 전략 비교

|전략|장점|단점|적합한 상황|
|---|---|---|---|
|**IDENTITY**|간단|배치 INSERT 불가|MySQL 단일 서버|
|**SEQUENCE**|배치 가능, 성능 좋음|DB 지원 필요|Oracle, PostgreSQL|
|**UUID**|분산 환경 적합|길고 정렬 불가|MSA, 분산 시스템|

## 실무 선택 가이드

```
MySQL → IDENTITY
PostgreSQL/Oracle → SEQUENCE
분산 시스템 → UUID 또는 Snowflake ID
```