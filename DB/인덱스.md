**데이터를 빠르게 찾기 위한 자료구조**입니다. 책의 색인(목차)과 같습니다.

---

## 비유

```
책에서 "React" 찾기:

인덱스 없음: 1페이지부터 끝까지 전부 읽음
인덱스 있음: 색인에서 "React → 152페이지" 확인 → 바로 이동
```

---

## 인덱스 없을 때

```sql
SELECT * FROM users WHERE name = '철수';
```

```
테이블 전체 스캔 (Full Table Scan)

| id | name   | age |
|----|--------|-----|
| 1  | 영희   | 25  |  ← 확인
| 2  | 민수   | 30  |  ← 확인
| 3  | 철수   | 28  |  ← 찾음!
| 4  | 지연   | 22  |  ← 확인 (끝까지 계속)
...
```

100만 건이면 100만 번 확인합니다.

---

## 인덱스 있을 때

```sql
CREATE INDEX idx_name ON users(name);
```

```
인덱스 (B-Tree)

        [민수]
       /      \
   [영희]    [철수]
              /
          [지연]

철수 찾기: 민수 → 오른쪽 → 철수 (3번 비교)
```

100만 건이어도 약 20번 비교로 찾습니다.

---

## B-Tree 구조

대부분의 DB가 사용하는 인덱스 구조입니다.

```
                    [50]
                   /    \
            [20, 30]    [70, 80]
            /  |  \      /  |  \
         [10][25][35] [60][75][90]
```

- 정렬된 상태 유지
- 범위 검색에 유리 (`BETWEEN`, `>`, `<`)
- 삽입/삭제 시 자동 균형 조정

---

## 장단점

|장점|단점|
|---|---|
|조회 빠름|저장 공간 추가 필요|
|정렬 빠름|INSERT/UPDATE/DELETE 느려짐|

```sql
-- INSERT 시
1. 테이블에 데이터 추가
2. 인덱스도 업데이트 (추가 작업)
```

---

## 언제 만드는가

```sql
-- 좋은 경우
CREATE INDEX idx_email ON users(email);  -- 자주 검색하는 컬럼
CREATE INDEX idx_created ON orders(created_at);  -- 정렬에 쓰는 컬럼

-- 안 좋은 경우
CREATE INDEX idx_gender ON users(gender);  -- 값이 몇 개 없음 (남/여)
```

|좋은 경우|나쁜 경우|
|---|---|
|WHERE절에 자주 사용|거의 조회 안 하는 컬럼|
|카디널리티 높음 (값 종류 많음)|카디널리티 낮음 (남/여 등)|
|조회 > 쓰기|쓰기 > 조회|