**여러 트랜잭션이 동시에 실행될 때 서로 얼마나 격리할지** 정하는 수준입니다.

---

## 4단계 격리 수준

| 레벨               | 설명              |
| ---------------- | --------------- |
| READ UNCOMMITTED | 커밋 안 된 데이터도 읽음  |
| READ COMMITTED   | 커밋된 데이터만 읽음     |
| REPEATABLE READ  | 같은 쿼리는 같은 결과 보장 |
| SERIAㄹLIZABLE    | 완전 격리           |

---

## 발생 가능한 문제 3가지

### 1. Dirty Read

**커밋 안 된 데이터를 읽음**

```
A: UPDATE age = 30 (커밋 전)
B: SELECT age → 30 읽음
A: ROLLBACK
B: 30을 믿고 로직 수행 → 문제!
```

### 2. Non-Repeatable Read

**같은 row인데 값이 달라짐**

```
A: SELECT age → 25
B: UPDATE age = 30, COMMIT
A: SELECT age → 30 (값이 바뀜!)
```

### 3. Phantom Read

**없던 row가 생김**

```
A: SELECT * WHERE age > 20 → 3건
B: INSERT (age=25), COMMIT
A: SELECT * WHERE age > 20 → 4건 (row 추가됨!)
```

---

## 격리 수준별 문제 발생

| 레벨               | Dirty Read | Non-Repeatable Read | Phantom Read |
| ---------------- | ---------- | ------------------- | ------------ |
| READ UNCOMMITTED | O          | O                   | O            |
| READ COMMITTED   | X          | O                   | O            |
| REPEATABLE READ  | X          | X                   | O            |
| SERIALIZABLE     | X          | X                   | X            |

아래로 갈수록 안전하지만 느려집니다.

---

## 각 레벨 상세

### READ UNCOMMITTED

```sql
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
```

- 다른 트랜잭션의 커밋 안 된 데이터도 읽음
- 가장 빠름, 가장 위험
- 거의 안 씀

### READ COMMITTED

```sql
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

- 커밋된 데이터만 읽음
- Oracle, PostgreSQL 기본값
- 실무에서 가장 많이 사용

### REPEATABLE READ

```sql
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

- 트랜잭션 시작 시점의 데이터를 계속 봄
- MySQL InnoDB 기본값

### SERIALIZABLE

```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

- 트랜잭션을 순차 실행하는 것처럼 동작
- 가장 안전, 가장 느림
- 금융 등 특수 상황에서 사용

---

## 격리 수준 vs 성능

```
격리 수준 높음 → 안전 ↑ 동시성 ↓ 성능 ↓
격리 수준 낮음 → 안전 ↓ 동시성 ↑ 성능 ↑
```

---

## 기본값

|DB|기본 격리 수준|
|---|---|
|MySQL|REPEATABLE READ|
|PostgreSQL|READ COMMITTED|
|Oracle|READ COMMITTED|

---
## 각 격리 레벨 동작 방식

### READ UNCOMMITTED

```
읽기: 락 X, 스냅샷 X → 메모리에 있는 값 그대로 읽음
쓰기: 배타 락 + 최신 데이터
```

```
트랜잭션 1                     트랜잭션 2
─────────                     ─────────
UPDATE 나이 = 30 (커밋 전)
                              SELECT 나이 → 30 (커밋 안 된 값!)
ROLLBACK
                              30을 믿고 로직 수행 → 문제!
```

---

### READ COMMITTED

```
읽기: 쿼리 시점 스냅샷 (쿼리마다 새로운 스냅샷)
쓰기: 배타 락 + 최신 데이터
```

```
트랜잭션 1                     트랜잭션 2
─────────                     ─────────
SELECT 나이 → 25 (현재 스냅샷)
                              UPDATE 나이 = 30
                              COMMIT
SELECT 나이 → 30 (새 스냅샷 → 값이 바뀜!)
```

---

### REPEATABLE READ

```
읽기: 트랜잭션 시작 시점 스냅샷 (끝까지 유지)
쓰기: 배타 락 + 최신 데이터
```

```
트랜잭션 1 (10시 시작)          트랜잭션 2
─────────                     ─────────
SELECT 나이 → 25 (10시 스냅샷)
                              UPDATE 나이 = 30
                              COMMIT
SELECT 나이 → 25 (여전히 10시 스냅샷)
```

---

### SERIALIZABLE

```
읽기: 트랜잭션 시작 시점 스냅샷 + 공유 락
쓰기: 배타 락 + 최신 데이터
```

```
트랜잭션 1                     트랜잭션 2
─────────                     ─────────
SELECT * WHERE 나이 >= 25
(스냅샷 + 공유 락)
                              INSERT (나이=28)
                              → 락 대기... (블로킹!)
COMMIT (락 해제)
                              (이제 INSERT 가능)
```

---

## 락 정리

|락 종류|다른 읽기|다른 쓰기|
|---|---|---|
|공유 락 (읽기)|가능|대기|
|배타 락 (쓰기)|대기|대기|

---

## 격리 수준별 동작 요약

|격리 수준|읽기 방식|쓰기 방식|
|---|---|---|
|READ UNCOMMITTED|현재 메모리 값|배타 락 + 최신 데이터|
|READ COMMITTED|쿼리 시점 스냅샷|배타 락 + 최신 데이터|
|REPEATABLE READ|트랜잭션 시작 스냅샷|배타 락 + 최신 데이터|
|SERIALIZABLE|트랜잭션 시작 스냅샷 + 공유 락|배타 락 + 최신 데이터|