소스코드와 OS/CPU 사이에 **추상화 계층(가상 머신)**을 두어 플랫폼 독립성·메모리 관리·보안 등을 얻는 대신, 시작 속도·메모리 오버헤드 등의 비용을 지불하는 구조입니다.

## VM이 있는 구조 vs 없는 구조

```
[ VM 사용 — Java, C#, Kotlin ]
소스코드 → 컴파일러 → 바이트코드 → VM → OS/CPU
                                  ↑
                          이 계층이 장점과 단점을 동시에 만듦

[ VM 미사용 — C, C++, Rust, Go ]
소스코드 → 컴파일러 → 네이티브 기계어 → OS/CPU 직접 실행
```

## 장점

### 1. 플랫폼 독립성

```
[ VM 없이 (C/C++) ]
소스코드 → Windows용 빌드 → Windows만 실행
        → macOS용 빌드   → macOS만 실행
        → Linux용 빌드   → Linux만 실행
        플랫폼마다 별도 컴파일 필요

[ VM 사용 (Java) ]
소스코드 → javac → .class (1회 컴파일)
                      │
            ┌─────────┼─────────┐
            ▼         ▼         ▼
         Windows    macOS     Linux
          JVM       JVM       JVM
```

바이트코드 하나로 모든 플랫폼에서 실행되므로 **"Write Once, Run Anywhere"** 가 가능합니다.

### 2. 자동 메모리 관리 (GC)

```c
// C — 개발자가 직접 관리
char *str = (char *)malloc(100);
// ... 사용 ...
free(str);        // 깜빡하면 메모리 누수
free(str);        // 실수로 두 번 해제하면 크래시
```

```java
// Java — VM이 자동 관리
String str = new String("hello");
str = null;       // 참조 끊김
// GC가 알아서 회수 → 누수·이중 해제 걱정 없음
```

|항목|수동 관리 (C/C++)|GC (VM)|
|---|---|---|
|메모리 누수|개발자 실수로 빈번|GC가 방지|
|이중 해제|크래시 유발|불가능|
|Dangling Pointer|심각한 버그 유발|불가능|
|개발 생산성|낮음 (신경 쓸 게 많음)|높음|

### 3. 런타임 최적화 (JIT)

```
[ AOT (C/C++) ]
컴파일 시점에 가능한 정보만으로 최적화
→ "실행 중 어떤 타입이 올지" 모름

[ JIT (VM) ]
런타임 프로파일링 데이터로 최적화
→ "이 메서드에 99% String이 들어온다" → 특화 코드 생성
→ 경우에 따라 AOT보다 더 빠름
```

### 4. 보안

```
[ VM 없이 ]
네이티브 바이너리가 OS 자원에 직접 접근
→ 버퍼 오버플로우, 포인터 조작 등 보안 취약

[ VM 사용 ]
┌──── VM 보안 계층 ────┐
│ 바이트코드 검증       │  ← 잘못된 코드 사전 차단
│ 배열 경계 검사        │  ← 버퍼 오버플로우 방지
│ 포인터 접근 차단      │  ← 임의 메모리 접근 불가
│ 샌드박스 실행         │  ← 시스템 자원 접근 제한
│ Security Manager     │  ← 파일·네트워크 접근 제어
└──────────────────────┘
```

### 5. 풍부한 런타임 기능

|기능|설명|
|---|---|
|**리플렉션**|런타임에 클래스 구조 탐색·조작|
|**동적 클래스 로딩**|실행 중 필요한 클래스만 로드|
|**런타임 모니터링**|jconsole, jstack 등으로 실시간 상태 확인|
|**스레드 관리**|VM 수준의 스레드 스케줄링, Virtual Threads|

### 6. 언어 생태계 공유

```
Java ──┐
Kotlin ─┤
Scala ──┤──→ 동일한 JVM 위에서 실행
Groovy ─┤     → 라이브러리 상호 사용 가능
Clojure ┘     → 동일한 GC·JIT 혜택
```

## 단점

### 1. 시작 속도 저하

```
[ 네이티브 바이너리 ]
OS가 바이너리를 메모리에 올림 → 즉시 실행
시작: ~1ms

[ JVM ]
JVM 초기화 → 클래스 로딩 → 바이트코드 검증 → Interpreter → JIT 워밍업
시작: ~500ms ~ 수 초
```

```
응답 속도
 ▲
 │  ┌─ 네이티브 (즉시 최대 성능)
 │  │
 │  │     ┌── JVM (JIT 워밍업 후)
 │  │    ╱
 │  │   ╱
 │  │──╱────── JVM 워밍업 구간
 │  │╱
 └──────────────────────────────► 시간
```

### 2. 메모리 오버헤드

```
[ C 프로그램 ]
프로그램 자체 메모리만 사용
총 메모리: ~10MB

[ Java 프로그램 (같은 기능) ]
┌─────────────────────────────┐
│ JVM 자체 메모리     ~100MB   │
│ 클래스 메타정보      ~30MB   │
│ JIT Code Cache     ~50MB   │
│ GC 여유 공간        ~50MB   │
│ 프로그램 실제 데이터  ~10MB   │
├─────────────────────────────┤
│ 총 메모리:          ~240MB  │
└─────────────────────────────┘
```

|항목|네이티브|VM|
|---|---|---|
|프로그램 자체|10MB|10MB|
|런타임 오버헤드|거의 없음|+200MB 이상|

### 3. GC로 인한 일시 정지 [[STW]](Stop-The-World) 

```
정상 실행 ────── STW ── 정상 실행 ───── STW ── 정상 실행

               ↑ GC가 객체 정리하는 동안
                 모든 스레드 일시 정지
                 수 ms ~ 수백 ms
```

|GC 종류|STW 시간|
|---|---|
|Serial|수백 ms|
|G1|수십 ms|
|ZGC|수 ms 이하|

최신 GC(ZGC, Shenandoah)로 많이 개선됐지만, **완전한 제거는 불가능**합니다. 이것이 실시간 시스템(항공, 의료기기 등)에서 VM 사용을 꺼리는 이유입니다.

### 4. 하드웨어 직접 제어 불가

```
[ C/C++ ]
포인터로 특정 메모리 주소 직접 접근 가능
하드웨어 레지스터 직접 조작 가능
→ OS 커널, 디바이스 드라이버, 임베디드 개발 가능

[ VM 언어 ]
VM이 메모리를 추상화
포인터 접근 차단
→ 시스템 프로그래밍에 부적합
→ JNI로 우회는 가능하나 VM의 장점을 상실
```

### 5. 배포 복잡성

```
[ Go 배포 ]
go build → 단일 바이너리 → 서버에 복사 → 실행 끝

[ Java 배포 ]
javac → .jar 생성 → 서버에 JRE 설치 확인 → JRE 버전 호환 확인 → 실행
                     ↑ 런타임 의존성 존재
```

## 장단점 요약

|항목|장점|단점|
|---|---|---|
|**플랫폼**|바이트코드 하나로 모든 OS|VM 설치 필요|
|**메모리 관리**|GC 자동 회수|GC STW 발생, 메모리 오버헤드|
|**성능**|JIT 런타임 최적화|시작 느림, 워밍업 필요|
|**보안**|바이트코드 검증, 샌드박스|하드웨어 직접 제어 불가|
|**생산성**|리플렉션, 동적 로딩 등 풍부한 기능|추상화 비용 (메모리, CPU)|
|**배포**|플랫폼 독립 배포|런타임 의존성 존재|

## 그래서 언제 VM을 쓰고, 언제 안 쓰는가

|상황|선택|이유|
|---|---|---|
|웹 서버, 엔터프라이즈|VM (Java, C#)|생산성, 생태계, 유지보수|
|OS 커널, 디바이스 드라이버|네이티브 (C, Rust)|하드웨어 직접 제어 필요|
|서버리스, CLI|네이티브 or AOT|즉시 시작 필요|
|게임 엔진|네이티브 (C++)|예측 가능한 성능, GC STW 불가|
|데이터 처리, AI|VM (JVM) + 네이티브|Spark(JVM) + GPU 커널(C++)|
|임베디드|네이티브 (C, Rust)|메모리 수 KB 환경|

## 핵심 정리

VM은 **플랫폼 독립성, 자동 메모리 관리, 런타임 최적화, 보안**이라는 강력한 장점을 제공하지만, **시작 속도, 메모리 오버헤드, GC 정지, 하드웨어 직접 제어 불가**라는 비용이 따릅니다. 이것은 우열이 아니라 트레이드오프이며, 엔터프라이즈 애플리케이션에서는 VM의 장점이 단점을 압도하기 때문에 Java와 C#이 여전히 주류로 사용됩니다.