자주 사용하는 데이터를 미리 복사해두고, 다음에 같은 요청이 오면 원본 대신 복사본을 빠르게 제공하는 기술입니다.

## 왜 필요한가?

- 매번 원본 데이터를 가져오면 시간이 오래 걸림
- 네트워크 요청, DB 조회, 연산 등은 비용이 큼
- 캐싱으로 속도 향상 + 서버 부하 감소

## 일상 속 비유

도서관에서 책을 빌리는 것보다 책상 위에 복사본을 두고 보는 게 빠른 것과 같습니다.

## 캐싱이 적용되는 곳

| 위치              | 예시                 |
| --------------- | ------------------ |
| **브라우저**        | 이미지, CSS, JS 파일 저장 |
| **DNS**         | 도메인-IP 매핑 저장       |
| **[[CDN]]**     | 전 세계 서버에 콘텐츠 복제    |
| **서버(Redis 등)** | DB 조회 결과 저장        |
| **DB**          | 쿼리 결과 캐싱           |
| **CPU**         | L1, L2, L3 캐시      |

## 캐시 동작 흐름

```
요청 → 캐시에 있나? 
         ├─ Yes (Cache Hit) → 캐시에서 반환 (빠름)
         └─ No (Cache Miss) → 원본에서 가져옴 → 캐시에 저장
```

## 주요 개념

- **Cache Hit**: 캐시에 데이터가 있음
- **Cache Miss**: 캐시에 없어서 원본 조회 필요
- **TTL(Time To Live)**: 캐시 유효 시간, 지나면 만료
- **Cache Invalidation**: 원본이 바뀌면 캐시를 갱신하거나 삭제

## 주의할 점

- 캐시된 데이터가 오래되면 **일관성 문제** 발생
- "캐시 무효화는 컴퓨터 과학에서 가장 어려운 문제 중 하나"라는 말이 있을 정도
