**[[MySQL]]의 기본 스토리지 엔진**입니다.

---

## 스토리지 엔진이란

```
MySQL 서버
    ├── SQL 파서 (쿼리 해석)
    ├── 옵티마이저 (실행 계획)
    └── 스토리지 엔진 (실제 데이터 저장/조회)
            ├── InnoDB ← 기본
            ├── MyISAM
            └── Memory
```

**데이터를 어떻게 저장하고 읽을지** 담당하는 부분입니다.

---

## InnoDB 특징

|특징|설명|
|---|---|
|트랜잭션 지원|ACID 보장|
|행 단위 잠금|동시성 높음|
|외래 키 지원|참조 무결성|
|인덱스|B+Tree 사용|
|크래시 복구|로그 기반 복구|

---

## InnoDB vs MyISAM

||InnoDB|MyISAM|
|---|---|---|
|트랜잭션|O|X|
|잠금 단위|행(Row)|테이블|
|외래 키|O|X|
|복구|자동 복구|수동 복구|
|용도|일반적인 서비스|읽기 전용, 로그|

---

## 사용법

```sql
-- 테이블 생성 시 지정
CREATE TABLE users (
    id INT PRIMARY KEY
) ENGINE=InnoDB;  -- 기본값이라 생략 가능

-- 현재 엔진 확인
SHOW TABLE STATUS;
```

MySQL 5.5부터 InnoDB가 기본이라, 대부분 그냥 InnoDB를 씁니다.

---
InnoDB에는 **두 종류의 인덱스**가 있고, 동작 방식이 다릅니다.
## 프라이머리 인덱스 (클러스터형)

PK로 만든 인덱스입니다. **리프 노드에 실제 데이터**가 있습니다.

```
           [PK: 50]
          /        \
    [PK: 20]      [PK: 80]
       ↓             ↓
  [실제 row]     [실제 row]
```

PK로 검색하면 **한 번의 탐색**으로 데이터를 찾습니다.

---

## 세컨더리 인덱스

PK 외의 컬럼으로 만든 인덱스입니다. **리프 노드에 PK 값**만 있습니다.

```sql
CREATE INDEX idx_name ON users(name);
```

```
        [name: 김]
       /         \
  [name: 강]   [name: 박]
      ↓           ↓
   [PK: 3]     [PK: 7]    ← 실제 데이터가 아니라 PK만!
```

---

## 세컨더리 인덱스로 검색하면

```sql
SELECT * FROM users WHERE name = '박';
```

```
1단계: 세컨더리 인덱스에서 name='박' 찾기
       → PK = 7 발견

2단계: 프라이머리 인덱스에서 PK=7 찾기
       → 실제 데이터 반환
```

**B-Tree를 두 번 탐색**합니다.

---

## 정리

|인덱스|리프 노드에 저장|탐색 횟수|
|---|---|---|
|프라이머리|실제 데이터|1번|
|세컨더리|PK 값|2번 (세컨더리 → 프라이머리)|

---

## 왜 이렇게 설계했나

세컨더리 인덱스에 실제 데이터를 저장하면:

```
데이터 수정 시 → 모든 인덱스의 데이터를 수정해야 함
```

PK만 저장하면:

```
데이터 수정 시 → 프라이머리 인덱스만 수정하면 됨
```

저장 공간과 수정 비용을 줄이기 위한 설계입니다.