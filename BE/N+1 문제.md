연관된 엔티티를 조회할 때 **1번의 쿼리로 N개의 결과를 가져온 후, 각 결과마다 추가 쿼리가 N번 발생**하는 문제입니다.

## 예시 상황

```java
@Entity
public class Team {
    @Id
    private Long id;
    private String name;
    
    @OneToMany(mappedBy = "team")
    private List<Member> members;
}

@Entity
public class Member {
    @Id
    private Long id;
    private String name;
    
    @ManyToOne
    private Team team;
}
```

```java
List<Team> teams = teamRepository.findAll(); // 팀 조회

for (Team team : teams) {
    System.out.println(team.getMembers().size()); // 멤버 접근
}
```

## 실제 발생하는 쿼리

```sql
-- 1번: 팀 전체 조회
SELECT * FROM team;

-- N번: 각 팀의 멤버 조회 (팀이 10개면 10번)
SELECT * FROM member WHERE team_id = 1;
SELECT * FROM member WHERE team_id = 2;
SELECT * FROM member WHERE team_id = 3;
...
```

팀이 100개면 총 101번의 쿼리가 발생합니다.

## 왜 발생하는가

JPA의 [[지연 로딩]](Lazy Loading) 때문입니다. `@OneToMany`는 기본이 `LAZY`라서 실제로 `getMembers()`를 호출할 때 쿼리가 나갑니다.

## 해결 방법

### 1. Fetch Join

```java
@Query("SELECT t FROM Team t JOIN FETCH t.members")
List<Team> findAllWithMembers();
```

```sql
-- 1번의 쿼리로 해결
SELECT * FROM team t 
INNER JOIN member m ON t.id = m.team_id;
```

### 2. EntityGraph

```java
@EntityGraph(attributePaths = {"members"})
@Query("SELECT t FROM Team t")
List<Team> findAllWithMembers();
```

### 3. Batch Size 설정

```java
@BatchSize(size = 100)
@OneToMany(mappedBy = "team")
private List<Member> members;
```

```sql
-- IN 절로 묶어서 조회
SELECT * FROM member WHERE team_id IN (1, 2, 3, ... 100);
```

또는 전역 설정:

```yaml
spring:
  jpa:
    properties:
      hibernate:
        default_batch_fetch_size: 100
```

## 각 방법의 특징

|방법|장점|단점|
|---|---|---|
|Fetch Join|쿼리 1번으로 해결|페이징 불가, 컬렉션 2개 이상 시 문제|
|EntityGraph|선언적, 재사용 가능|Fetch Join과 동일한 한계|
|Batch Size|페이징 가능, 설정 간단|쿼리가 1번은 아님 (1 + N/batchSize)|

실무에서는 보통 Batch Size를 전역으로 설정해두고, 필요한 곳에서 Fetch Join을 사용하는 조합이 많이 쓰입니다.